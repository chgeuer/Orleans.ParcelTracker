# Playing with priority queues

```elixir
Mix.install([
  # {:treex, "~> 0.1.0"}
])
```

## The `PriorityQueue` data structure

```elixir
make_ref()
```

The `PriorityQueue` module represents the pure functional data structure. It uses Erlang's `:gb_trees` and `:queue` data structures.

```elixir
defmodule PriorityQueue do
  defstruct size: 0, tree: nil

  def new, do: %__MODULE__{size: 0, tree: :gb_trees.empty()}

  def empty?(%__MODULE__{size: 0}), do: true
  def empty?(%__MODULE__{}), do: false

  @doc ~S"""
  Returns the size of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...>   |> PriorityQueue.size()
      0

      iex> PriorityQueue.new()
      ...>   |> PriorityQueue.push(1, "Some item")
      ...>   |> PriorityQueue.size()
      1

  """
  def size(%__MODULE__{size: n}), do: n

  def push(pq = %__MODULE__{size: n, tree: tree}, priority, value) when is_integer(priority) do
    tree =
      case :gb_trees.lookup(priority, tree) do
        {:value, queue} -> :gb_trees.update(priority, :queue.in(value, queue), tree)
        :none -> :gb_trees.insert(priority, :queue.in(value, :queue.new()), tree)
      end

    %{pq | size: n + 1, tree: tree}
  end

  def push_r(pq = %__MODULE__{size: n, tree: tree}, priority, value) when is_integer(priority) do
    tree =
      case :gb_trees.lookup(priority, tree) do
        {:value, queue} -> :gb_trees.update(priority, :queue.in_r(value, queue), tree)
        :none -> :gb_trees.insert(priority, :queue.in_r(value, :queue.new()), tree)
      end

    %{pq | size: n + 1, tree: tree}
  end

  @doc ~S"""
  Returns the pairs of a `PriorityQueue

  ## Examples

      iex> queue = 
      ...>   PriorityQueue.new()
      ...>   |> PriorityQueue.push(2, "Lower prio")
      ...>   |> PriorityQueue.push(1, "Higher prio")
      ...>   |> PriorityQueue.push(3, :very_low_prio)
      ...>   |> PriorityQueue.push(2, { :job, "Some other thing in 2" })
      iex> { result, queue } = queue |> PriorityQueue.pop(); result
      { :value, 1, "Higher prio" }
      iex> { result, queue } = queue |> PriorityQueue.pop(); result
      { :value, 2, "Lower prio" }
      iex> { result, queue } = queue |> PriorityQueue.pop(); result
      { :value, 2, { :job, "Some other thing in 2" } }
      iex> { result, _queue } = queue |> PriorityQueue.pop(); result
      { :value, 3, :very_low_prio }

      iex> { result, _queue } = PriorityQueue.new()
      ...> |> PriorityQueue.pop()
      iex> result
      :none
  """
  def pop(pq = %__MODULE__{size: 0}), do: {:none, pq}

  def pop(%__MODULE__{size: n, tree: tree}) do
    {priority, queue, tree} = :gb_trees.take_smallest(tree)
    {{:value, value}, queue} = :queue.out(queue)

    tree =
      case :queue.is_empty(queue) do
        false -> :gb_trees.enter(priority, queue, tree)
        true -> tree
      end

    {{:value, priority, value}, %__MODULE__{size: n - 1, tree: tree}}
  end

  @doc ~S"""
  Returns the keys of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(2, "Lower prio")
      ...> |> PriorityQueue.push(1, "Higher prio")
      ...> |> PriorityQueue.keys()

      [ 1, 2 ]

  """
  def keys(%__MODULE__{tree: tree}), do: :gb_trees.keys(tree)

  defp values(pq = %__MODULE__{}, list) do
    case pq |> pop() do
      {:none, _} -> list |> :lists.reverse()
      {{:value, _priority, value}, pq} -> values(pq, [value | list])
    end
  end

  @doc ~S"""
  Returns the values of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(2, "Lower prio")
      ...> |> PriorityQueue.push(1, "Higher prio")
      ...> |> PriorityQueue.values()

      [ "Higher prio", "Lower prio" ]

  """
  def values(pq = %__MODULE__{}) do
    values(pq, [])
  end

  defp pairs(pq = %__MODULE__{}, list) do
    case pq |> pop() do
      {:none, _} -> list |> :lists.reverse()
      {{:value, priority, value}, pq} -> pairs(pq, [{priority, value} | list])
    end
  end

  @doc ~S"""
  Returns the pairs of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(2, "Lower prio")
      ...> |> PriorityQueue.push(1, "Higher prio")
      ...> |> PriorityQueue.push(3, :very_low_prio)
      ...> |> PriorityQueue.push(2, { :job, "Some other thing in 2" })
      ...> |> PriorityQueue.pairs()

      [
        { 1, "Higher prio" },
        { 2, "Lower prio" },
        { 2, { :job, "Some other thing in 2" } },
        { 3, :very_low_prio }
      ]

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(100, 9)
      ...> |> PriorityQueue.push(1, 1)
      ...> |> PriorityQueue.push(2, 5)
      ...> |> PriorityQueue.push(1, 2)
      ...> |> PriorityQueue.push(2, 6)
      ...> |> PriorityQueue.push(1, 3)
      ...> |> PriorityQueue.push(10, 8)
      ...> |> PriorityQueue.push(1, 4)
      ...> |> PriorityQueue.push(2, 7)
      ...> |> PriorityQueue.pairs()

      [
        {1, 1}, {1, 2}, {1, 3}, {1, 4},
        {2, 5}, {2, 6}, {2, 7},
        {10, 8},
        {100, 9}
      ]
  """
  def pairs(pq = %__MODULE__{}) do
    pairs(pq, [])
  end
end
```

```elixir
PriorityQueue.new()
|> PriorityQueue.push(100, 9)
|> PriorityQueue.push(1, 1)
|> PriorityQueue.push(2, 5)
|> PriorityQueue.push(1, 2)
|> PriorityQueue.push(2, 6)
|> PriorityQueue.push(1, 3)
|> PriorityQueue.push(10, 8)
|> PriorityQueue.push(1, 4)
|> PriorityQueue.push(2, 7)
|> PriorityQueue.pairs()
```

### The `GenServer` wrapped around the `PriorityQueue` data structure

The following module wraps the functional data structure in a `GenServer`.

* [Example](https://medium.com/blackode/2-unique-use-cases-of-genserver-reply-deep-insights-elixir-expert-31e7abbd42d1) on how to use `{:noreply, ...}` in a `handle_call()` callback.

```elixir
defmodule PriorityQueueServer do
  use GenServer
  require Logger

  # Client
  def start_link(), do: GenServer.start_link(__MODULE__, PriorityQueue.new())

  def push(pid, priority, value), do: GenServer.cast(pid, {:push, priority, value})

  # :infinity,
  def pop(pid, timeout \\ 5000), do: GenServer.call(pid, :pop, timeout)

  # Server
  @impl true
  def init(state = %PriorityQueue{}), do: {:ok, state}

  @impl true
  def handle_cast({:push, priority, value}, priority_queue) do
    {:noreply, priority_queue |> PriorityQueue.push(priority, value)}
  end

  @impl true
  def handle_call(:pop, _from, priority_queue = %PriorityQueue{}) do
    {reply_value, priority_queue} = priority_queue |> PriorityQueue.pop()
    {:reply, reply_value, priority_queue}
  end
end
```

```elixir
defmodule PriorityQueueServerWithConfirmation do
  use GenServer
  require Logger

  defstruct pq: nil, in_flight: nil

  # Client
  def start_link(),
    do: GenServer.start_link(__MODULE__, %__MODULE__{pq: PriorityQueue.new(), in_flight: %{}})

  def push(pid, priority, value), do: GenServer.cast(pid, {:push, priority, value})

  # :infinity,
  def pop(pid, timeout \\ 5000), do: GenServer.call(pid, {:pop, timeout})

  def finished(pid, ref), do: GenServer.call(pid, {:finished, ref})

  def length(pid), do: GenServer.call(pid, :length)

  # Server
  @impl true
  def init(state = %__MODULE__{}), do: {:ok, state}

  @impl true
  def handle_cast({:push, priority, value}, state = %__MODULE__{pq: pq}) do
    state = %{state | pq: PriorityQueue.push(pq, priority, value)}
    {:noreply, state}
  end

  @impl true
  def handle_call({:pop, timeout}, _from, state = %__MODULE__{pq: pq, in_flight: in_flight}) do
    {item, new_pq} = pq |> PriorityQueue.pop()

    case item do
      :none ->
        {:reply, :none, state}

      {:value, priority, value} ->
        ref = make_ref()
        in_flight = in_flight |> Map.put(ref, {priority, value})
        state = %{state | pq: new_pq, in_flight: in_flight}

        # After the timeout, check whether the item has been processed
        Process.send_after(self(), {:reschedule, ref}, timeout)

        {:reply, {:value, priority, value, ref}, state}
    end
  end

  @impl true
  def handle_call({:finished, ref}, _from, state = %__MODULE__{in_flight: in_flight}) do
    case in_flight |> Map.pop(ref) do
      {nil, _} ->
        {:reply, :not_found, state}

      {{_priority, _value}, in_flight} ->
        {:reply, :ok, %{state | in_flight: in_flight}}
    end
  end

  def handle_call(:length, _from, state = %__MODULE__{pq: priority_queue}) do
    reply_value = priority_queue |> PriorityQueue.size()
    {:reply, reply_value, state}
  end

  @impl true
  def handle_info({:reschedule, ref}, state = %__MODULE__{pq: pq, in_flight: in_flight}) do
    case in_flight |> Map.pop(ref) do
      {nil, _} ->
        # If the reference isn't there any longer...
        {:noreply, state}

      {{priority, value}, in_flight} ->
        # The reference hasn't been handled in due time, so we re-enqueue it.
        state = %{state | pq: PriorityQueue.push_r(pq, priority, value), in_flight: in_flight}
        {:noreply, state}
    end
  end
end
```

```elixir
defmodule MyTask do
  require Logger

  def launch(name) do
    {:ok, pid} = PriorityQueueServerWithConfirmation.start_link()
    Process.register(pid, name)
  end

  def send_data(name) do
    name |> PriorityQueueServerWithConfirmation.push(100, 9)
    name |> PriorityQueueServerWithConfirmation.push(1, 1)
    name |> PriorityQueueServerWithConfirmation.push(2, 5)
    name |> PriorityQueueServerWithConfirmation.push(1, 2)
    name |> PriorityQueueServerWithConfirmation.push(2, 6)
    name |> PriorityQueueServerWithConfirmation.push(1, 3)
    name |> PriorityQueueServerWithConfirmation.push(10, 8)
    name |> PriorityQueueServerWithConfirmation.push(1, 4)
    name |> PriorityQueueServerWithConfirmation.push(2, 7)
  end

  def fetch_data(name) do
    case name |> PriorityQueueServerWithConfirmation.pop() do
      :none ->
        IO.puts("Queue #{name} is empty")

      {:value, prio, val, ref} ->
        IO.puts("Fetched #{val} with prio #{prio} from queue #{name}")
        PriorityQueueServerWithConfirmation.finished(name, ref)
        fetch_data(name)
    end
  end

  defp pairs(pid, list) do
    case pid |> PriorityQueueServerWithConfirmation.pop() do
      :none ->
        list |> :lists.reverse()

      {:value, priority, value, ref} ->
        PriorityQueueServerWithConfirmation.finished(pid, ref)
        pairs(pid, [{priority, value} | list])
    end
  end

  def pairs(pid), do: pid |> pairs([])
end
```

```elixir
name = :f
```

```elixir
MyTask.launch(name)
```

```elixir
name |> PriorityQueueServerWithConfirmation.push(100, 9)
name |> PriorityQueueServerWithConfirmation.push(1, 1)
```

```elixir
PriorityQueueServerWithConfirmation.pop(name)
```

```elixir
:sys.get_state(name)
```

```elixir
MyTask.pairs(name)
```

```elixir
case PriorityQueueServer.pop(name) do
  {:value, priority, value, ref} ->
    IO.puts("Received #{inspect(value)} with prio #{priority} (handle: #{inspect(ref)})")
    IO.puts("Before: #{inspect(:sys.get_state(name))}")
    PriorityQueueServer.finished(name, ref)
    IO.puts("After: #{inspect(:sys.get_state(name))}")

  :none ->
    :none
end
```

```elixir
:sys.get_state(:f)
```

```elixir
# :fedex |> MyTask.send_data()

:fedex |> PriorityQueueServer.push(100, 9)
:fedex |> PriorityQueueServer.push(1, 1)
:fedex |> PriorityQueueServer.push(2, 5)
:fedex |> PriorityQueueServer.push(1, 2)
:fedex |> PriorityQueueServer.push(2, 6)
:fedex |> PriorityQueueServer.push(1, 3)
:fedex |> PriorityQueueServer.push(10, 8)
:fedex |> PriorityQueueServer.push(1, 4)
:fedex |> PriorityQueueServer.push(2, 7)
len = :fedex |> PriorityQueueServer.length()
IO.puts("There are now #{len} items in the queue")
```

## Fetch data from the GenServer

```elixir
:fedex |> MyTask.pairs()
```

## Put some data into the GenServer

```elixir
pid = :fedex

[
  {1, "Top prio #{DateTime.utc_now()}"},
  {10, "Some batch crap  #{DateTime.utc_now()}"},
  {5, "Medium stuff  #{DateTime.utc_now()}"},
  {1, "Yet another important one  #{DateTime.utc_now()}"}
]
|> Enum.map(fn {priority, value} -> pid |> PriorityQueueServer.push(priority, value) end)
```

## Show currently enqueued items

```elixir
pid |> :sys.get_state() |> IO.inspect(label: :full_state)

pid |> :sys.get_state() |> Map.get(:priority_queue) |> PriorityQueue.pairs()
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
case pid |> PriorityQueueServer.pop() do
  {:value, priority, value} ->
    IO.puts("Received #{inspect(value)} with prio #{priority}")
    :ok

  other ->
    IO.puts("Received #{inspect(other)}")
end

pid |> :sys.get_state() |> Map.get(:priority_queue) |> PriorityQueue.pairs()
```
