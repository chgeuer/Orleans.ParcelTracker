# Playing with priority queues

```elixir
Mix.install([
  {:treex, "~> 0.1.0"}
])
```

## The `PriorityQueue` data structure

The `PriorityQueue` module represents the pure functional data structure. It uses the [`:treex`](https://hexdocs.pm/treex/api-reference.html) module to have a better UX interacting with Erlang's `gb_trees` data structure.

```elixir
defmodule PriorityQueue do
  defstruct size: 0, treex: nil

  def new, do: %__MODULE__{size: 0, treex: Treex.empty()}

  # def empty?(%__MODULE__{treex: tree}), do: tree |> Treex.empty?()
  def empty?(%__MODULE__{size: 0}), do: true
  def empty?(%__MODULE__{}), do: false
  def empty?(_), do: false

  @doc ~S"""
  Returns the size of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...>   |> PriorityQueue.size()
      0

      iex> PriorityQueue.new()
      ...>   |> PriorityQueue.push(1, "Some item")
      ...>   |> PriorityQueue.size()
      1

  """
  def size(%__MODULE__{size: n}), do: n

  def push(pq = %__MODULE__{size: n, treex: tree}, priority, value) when is_integer(priority) do
    tree =
      case tree |> Treex.lookup(priority) do
        {:value, queue} -> tree |> Treex.update!(priority, :queue.in(value, queue))
        :none -> tree |> Treex.insert!(priority, :queue.in(value, :queue.new()))
      end

    %{pq | size: n + 1, treex: tree}
  end

  @doc ~S"""
  Returns the pairs of a `PriorityQueue

  ## Examples

      iex> queue = PriorityQueue.new()
      ...>     |> PriorityQueue.push(2, "Lower prio")
      ...>     |> PriorityQueue.push(1, "Higher prio")
      ...>     |> PriorityQueue.push(3, :very_low_prio)
      ...>     |> PriorityQueue.push(2, { :job, "Some other thing in 2" })
      iex> { result, queue } = queue |> PriorityQueue.pop(); result
      { :value, 1, "Higher prio" }
      iex> { result, queue } = queue |> PriorityQueue.pop(); result
      { :value, 2, "Lower prio" }
      iex> { result, queue } = queue |> PriorityQueue.pop(); result
      { :value, 2, { :job, "Some other thing in 2" } }
      iex> { result, _queue } = queue |> PriorityQueue.pop(); result
      { :value, 3, :very_low_prio }

      iex> { result, _queue } = PriorityQueue.new()
      ...> |> PriorityQueue.pop()
      iex> result
      :none
  """
  def pop(pq = %__MODULE__{size: 0}), do: {:none, pq}

  def pop(%__MODULE__{size: n, treex: tree}) do
    {priority, queue, tree} = tree |> Treex.take_smallest!()
    {{:value, value}, queue} = :queue.out(queue)

    tree =
      case :queue.is_empty(queue) do
        false -> tree |> Treex.enter(priority, queue)
        true -> tree
      end

    {{:value, priority, value}, %__MODULE__{size: n - 1, treex: tree}}
  end

  @doc ~S"""
  Returns the keys of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(2, "Lower prio")
      ...> |> PriorityQueue.push(1, "Higher prio")
      ...> |> PriorityQueue.keys()

      [ 1, 2 ]

  """
  def keys(%__MODULE__{treex: tree}), do: tree |> Treex.keys()

  defp values(pq = %__MODULE__{}, list) do
    case pq |> pop() do
      {:none, _} -> list |> :lists.reverse()
      {{:value, _priority, value}, pq} -> values(pq, [value | list])
    end
  end

  @doc ~S"""
  Returns the values of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(2, "Lower prio")
      ...> |> PriorityQueue.push(1, "Higher prio")
      ...> |> PriorityQueue.values()

      [ "Higher prio", "Lower prio" ]

  """
  def values(pq = %__MODULE__{}) do
    values(pq, [])
  end

  defp pairs(pq = %__MODULE__{}, list) do
    case pq |> pop() do
      {:none, _} -> list |> :lists.reverse()
      {{:value, priority, value}, pq} -> pairs(pq, [{priority, value} | list])
    end
  end

  @doc ~S"""
  Returns the pairs of a `PriorityQueue

  ## Examples

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(2, "Lower prio")
      ...> |> PriorityQueue.push(1, "Higher prio")
      ...> |> PriorityQueue.push(3, :very_low_prio)
      ...> |> PriorityQueue.push(2, { :job, "Some other thing in 2" })
      ...> |> PriorityQueue.pairs()

      [
        { 1, "Higher prio" },
        { 2, "Lower prio" },
        { 2, { :job, "Some other thing in 2" } },
        { 3, :very_low_prio }
      ]

      iex> PriorityQueue.new()
      ...> |> PriorityQueue.push(100, 9)
      ...> |> PriorityQueue.push(1, 1)
      ...> |> PriorityQueue.push(2, 5)
      ...> |> PriorityQueue.push(1, 2)
      ...> |> PriorityQueue.push(2, 6)
      ...> |> PriorityQueue.push(1, 3)
      ...> |> PriorityQueue.push(10, 8)
      ...> |> PriorityQueue.push(1, 4)
      ...> |> PriorityQueue.push(2, 7)
      ...> |> PriorityQueue.pairs()

      [
        {1, 1}, {1, 2}, {1, 3}, {1, 4},
        {2, 5}, {2, 6}, {2, 7},
        {10, 8},
        {100, 9}
      ]
  """
  def pairs(pq = %__MODULE__{}) do
    pairs(pq, [])
  end
end
```

```elixir
PriorityQueue.new()
|> PriorityQueue.push(100, 9)
|> PriorityQueue.push(1, 1)
|> PriorityQueue.push(2, 5)
|> PriorityQueue.push(1, 2)
|> PriorityQueue.push(2, 6)
|> PriorityQueue.push(1, 3)
|> PriorityQueue.push(10, 8)
|> PriorityQueue.push(1, 4)
|> PriorityQueue.push(2, 7)
|> PriorityQueue.pairs()
```

### The `GenServer` wrapped around the `PriorityQueue` data structure

The following module wraps the functional data structure in a `GenServer`.

* [Example](https://medium.com/blackode/2-unique-use-cases-of-genserver-reply-deep-insights-elixir-expert-31e7abbd42d1) on how to use `{:noreply, ...}` in a `handle_call()` callback.

```elixir
defmodule PriorityQueueServer do
  use GenServer
  require Logger

  # Client
  def start_link(), do: GenServer.start_link(__MODULE__, PriorityQueue.new())

  def push(pid, priority, value), do: GenServer.cast(pid, {:push, priority, value})

  # :infinity,
  def pop(pid, timeout \\ 5000), do: GenServer.call(pid, :pop, timeout)

  def length(pid), do: GenServer.call(pid, :length)

  # Server
  @impl true
  def init(state = %PriorityQueue{}), do: {:ok, state}

  @impl true
  def handle_cast({:push, priority, value}, priority_queue) do
    {:noreply, priority_queue |> PriorityQueue.push(priority, value)}
  end

  @impl true
  def handle_call(:pop, _from, priority_queue = %PriorityQueue{}) do
    {reply_value, priority_queue} = priority_queue |> PriorityQueue.pop()
    {:reply, reply_value, priority_queue}
  end

  def handle_call(:length, _from, priority_queue = %PriorityQueue{}) do
    reply_value = priority_queue |> PriorityQueue.size()
    {:reply, reply_value, priority_queue}
  end
end
```

```elixir
defmodule MyTask do
  require Logger

  def launch(name) do
    {:ok, pid} = PriorityQueueServer.start_link()
    Process.register(pid, name)
  end

  def send_data(name) do
    name |> PriorityQueueServer.push(100, 9)
    name |> PriorityQueueServer.push(1, 1)
    name |> PriorityQueueServer.push(2, 5)
    name |> PriorityQueueServer.push(1, 2)
    name |> PriorityQueueServer.push(2, 6)
    name |> PriorityQueueServer.push(1, 3)
    name |> PriorityQueueServer.push(10, 8)
    name |> PriorityQueueServer.push(1, 4)
    name |> PriorityQueueServer.push(2, 7)
  end

  def fetch_data(name) do
    case name |> PriorityQueueServer.pop() do
      :none ->
        IO.puts("Queue #{name} is empty")

      {:value, prio, val} ->
        IO.puts("Fetched #{val} with prio #{prio} from queue #{name}")
        fetch_data(name)
    end
  end

  defp pairs(pid, list) do
    case pid |> PriorityQueueServer.pop() do
      :none -> list |> :lists.reverse()
      {:value, priority, value} -> pairs(pid, [{priority, value} | list])
    end
  end

  def pairs(pid), do: pid |> pairs([])
end
```

```elixir
MyTask.launch(:fedex)
```

```elixir
# :fedex |> MyTask.send_data()

:fedex |> PriorityQueueServer.push(100, 9)
:fedex |> PriorityQueueServer.push(1, 1)
:fedex |> PriorityQueueServer.push(2, 5)
:fedex |> PriorityQueueServer.push(1, 2)
:fedex |> PriorityQueueServer.push(2, 6)
:fedex |> PriorityQueueServer.push(1, 3)
:fedex |> PriorityQueueServer.push(10, 8)
:fedex |> PriorityQueueServer.push(1, 4)
:fedex |> PriorityQueueServer.push(2, 7)
len = :fedex |> PriorityQueueServer.length()
IO.puts("There are now #{len} items in the queue")
```

## Fetch data from the GenServer

```elixir
:fedex |> MyTask.pairs()
```

## Put some data into the GenServer

```elixir
pid = :fedex

[
  {1, "Top prio #{DateTime.utc_now()}"},
  {10, "Some batch crap  #{DateTime.utc_now()}"},
  {5, "Medium stuff  #{DateTime.utc_now()}"},
  {1, "Yet another important one  #{DateTime.utc_now()}"}
]
|> Enum.map(fn {priority, value} -> pid |> PriorityQueueServer.push(priority, value) end)
```

## Show currently enqueued items

```elixir
pid |> :sys.get_state() |> IO.inspect(label: :full_state)

pid |> :sys.get_state() |> Map.get(:priority_queue) |> PriorityQueue.pairs()
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
case pid |> PriorityQueueServer.pop() do
  {:value, priority, value} ->
    IO.puts("Received #{inspect(value)} with prio #{priority}")
    :ok

  other ->
    IO.puts("Received #{inspect(other)}")
end

pid |> :sys.get_state() |> Map.get(:priority_queue) |> PriorityQueue.pairs()
```
